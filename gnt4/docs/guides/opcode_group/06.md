# Opcode Group 06

Instructions in this opcode group seem to be related to comparing values. These will set values to the Comparison Register (`cr`). Opcodes in this opcode group are often followed by opcodes from [opcode group 01](01.md), as the comparison happens in opcode group 04 and the branch happens in opcode group 01.

This opcode group is primarily for `short` values.


## 0600 - debug08

Unknown debug print using `sprintf`.

## 0601

## 0602 - s_mov

Move short (and compare).

Get two shorts from `get_effective_addresses`. Move the second into the first (`first = second`). Store the first value into `cr`.

## 0603 - s_andws

Short logical and (without store).

Get two shorts from `get_effective_addresses`. Logical `and` the first value with the second value and store the result in `cr` (`cr = first & second`).

## 0604 - s_nimply

Short non-implication.

Get two shorts from `get_effective_addresses`. Logical `not` the second value and logical `and` the result with the `first`; store this new result into the first (`first = first & ~second`). Store the result into `cr`.

## 0605 - s_inc

Short increment.

Get one short from `get_effective_address`. Increment and store it (`value = value++`). Store the result into `cr`.

## 0606 - s_dec

Short decrement.

Get one short from `get_effective_address`. Decrement and store it (`value = value--`). Store the result into `cr`.

## 0607 - s_add

Short add.

Get two shorts from `get_effective_addresses`. Add them and store the result in the first (`first = first + second`). Store the new value into `cr`.

## 0608 - s_sub

Short subtract.

Get two shorts from `get_effective_addresses`. Subtract them and store the result in the first (`first = first - second`). Store the new value into `cr`.

## 0609 - s_mul

Short multiply.

Get two shorts from `get_effective_addresses`. Multiply them and store the result in the first (`first = first * second`). Store the new value into `cr`.

## 060A - s_div

Short divide.

Get two shorts from `get_effective_addresses`. Divide them and store the result in the first (`first = first / second`). Store the new value into `cr`.

## 060B - s_shl

Short shift left.

Get two shorts from `get_effective_addresses`. Shift the first value left by the second value and store the result in the first (`first = first << second`). Store the new value into `cr`.

## 060C - s_shr

Short shift right.

Get two shorts from `get_effective_addresses`. Shift the first value right by the second value and store the result in the first (`first = first >> second`). Store the new value into `cr`.

## 060D - s_and

Short logical and.

Get two shorts from `get_effective_addresses`. Logical `and` the first value with the second value and store the result in the first (`first = first & second`). Store the new value into `cr`.

## 060E - s_or

Short logical or.

Get two shorts from `get_effective_addresses`. Logical `or` the first value with the second value and store the result in the first (`first = first | second`). Store the new value into `cr`.

## 060F - s_xor

Short logical xor.

Get two shorts from `get_effective_addresses`. Logical `xor` the first value with the second value and store the result in the first (`first = first ^ second`). Store the new value into `cr`.

## 0610 - s_not

Short logical not.

Get two shorts from `get_effective_addresses`. Logical `not` the second value and store the result in the first (`first = ~second`). Store the new value into `cr`.

## 0611 - s_subws

Short subtraction (without store).

Get two shorts from `get_effective_addresses`. Subtract them and store the result in `cr` ((`cr = first - second`)).

## 0612 - s_chs

Integer change sign.

Get two integers from `get_effective_addresses`. Change the sign of the second value and store the result in the first (`first = -(second)`). Store the new value into `cr`.

## 0613

Dupe of opcode 0602?

## 0614

## 0615

## 0616
