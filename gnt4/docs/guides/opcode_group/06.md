# Opcode Group 06 - SEQ_CmdIS

Short operations (2 bytes).

## 0600 - s_debug

Unknown debug print using `sprintf`.

## 0601 - s_float

Convert short to float.

Get two shorts from `SEQ_RegCMD2`. Convert the second into a float and store it in the first.

## 0602 - s_mov

Move short (and compare).

Get two shorts from `SEQ_RegCMD2`. Move the second into the first (`first = second`). Store the first value into `cr`.

## 0603 - s_and.

Short logical and (without store).

Get two shorts from `SEQ_RegCMD2`. Logical `and` the first value with the second value and store the result in `cr` (`cr = first & second`).

## 0604 - s_nimply

Short non-implication.

Get two shorts from `SEQ_RegCMD2`. Logical `not` the second value and logical `and` the result with the `first`; store this new result into the first (`first = first & ~second`). Store the result into `cr`.

## 0605 - s_inc

Short increment.

Get one short from `SEQ_RegCMD1`. Increment and store it (`value = value++`). Store the result into `cr`.

## 0606 - s_dec

Short decrement.

Get one short from `SEQ_RegCMD1`. Decrement and store it (`value = value--`). Store the result into `cr`.

## 0607 - s_add

Short add.

Get two shorts from `SEQ_RegCMD2`. Add them and store the result in the first (`first = first + second`). Store the new value into `cr`.

## 0608 - s_sub

Short subtract.

Get two shorts from `SEQ_RegCMD2`. Subtract them and store the result in the first (`first = first - second`). Store the new value into `cr`.

## 0609 - s_mul

Short multiply.

Get two shorts from `SEQ_RegCMD2`. Multiply them and store the result in the first (`first = first * second`). Store the new value into `cr`.

## 060A - s_div

Short divide.

Get two shorts from `SEQ_RegCMD2`. Divide them and store the result in the first (`first = first / second`). Store the new value into `cr`.

## 060B - s_shl

Short shift left.

Get two shorts from `SEQ_RegCMD2`. Shift the first value left by the second value and store the result in the first (`first = first << second`). Store the new value into `cr`.

## 060C - s_shr

Short shift right.

Get two shorts from `SEQ_RegCMD2`. Shift the first value right by the second value and store the result in the first (`first = first >> second`). Store the new value into `cr`.

## 060D - s_and

Short logical and.

Get two shorts from `SEQ_RegCMD2`. Logical `and` the first value with the second value and store the result in the first (`first = first & second`). Store the new value into `cr`.

## 060E - s_or

Short logical or.

Get two shorts from `SEQ_RegCMD2`. Logical `or` the first value with the second value and store the result in the first (`first = first | second`). Store the new value into `cr`.

## 060F - s_xor

Short logical xor.

Get two shorts from `SEQ_RegCMD2`. Logical `xor` the first value with the second value and store the result in the first (`first = first ^ second`). Store the new value into `cr`.

## 0610 - s_not

Short logical not.

Get two shorts from `SEQ_RegCMD2`. Logical `not` the second value and store the result in the first (`first = ~second`). Store the new value into `cr`.

## 0611 - s_sub.

Short subtraction (without store).

Get two shorts from `SEQ_RegCMD2`. Subtract them and store the result in `cr` ((`cr = first - second`)).

## 0612 - s_chs

Integer change sign.

Get two integers from `SEQ_RegCMD2`. Change the sign of the second value and store the result in the first (`first = -(second)`). Store the new value into `cr`.

## 0613

Dupe of opcode 0602?

## 0614

## 0615

## 0616
