# Opcode Group 05 - SEQ_CmdIC

Char operations (1 byte).

- [0500 - i8_debug](#0400---i8_debug)
- [0501 - i8_float](#0401---i8_float)
- [0502 - i8_mov](#0402---i8_mov)
- [0503 - i8_and.](#0403---i8_and.)
- [0504 - i8_nimply](#0404---i8_nimply)
- [0505 - i8_inc](#0405---i8_inc)
- [0506 - i8_dec](#0406---i8_dec)
- [0507 - i8_add](#0407---i8_add)
- [0508 - i8_sub](#0408---i8_sub)
- [0509 - i8_mul](#0409---i8_mul)
- [050A - i8_div](#040A---i8_div)
- [050B - i8_shl](#040B---i8_shl)
- [050C - i8_shr](#040C---i8_shr)
- [050D - i8_and](#040D---i8_and)
- [050E - i8_or](#040E---i8_or)
- [050F - i8_xor](#040F---i8_xor)
- [0510 - i8_not](#0410---i8_not)
- [0511 - i8_sub.](#0411---i8_sub.)
- [0512 - i8_chs](#0412---i8_chs)
- [0513](#0413)
- [0514](#0414)
- [0515 - i8_rand](#0415---i8_rand)
- [0516](#0416)

## 0400 - i8_debug

Debug `sprintf` the given parameter using the print format `"0x%x(%d)"`.

## 0401 - i8_float

Convert char to float.

Get two chars from `SEQ_RegCMD2`. Convert the second into a float and store it in the first.

## 0402 - i8_mov

Move char (and compare).

Get two chars from `SEQ_RegCMD2`. Move the second into the first (`first = second`). Store the first value into `cr`.

## 0403 - i8_and.

Char logical and (without store).

Get two chars from `SEQ_RegCMD2`. Logical `and` the first value with the second value and store the result in `cr` (`cr = first & second`).

## 0404 - i8_nimply

Char non-implication.

Get two chars from `SEQ_RegCMD2`. Logical `not` the second value and logical `and` the result with the `first`; store this new result into the first (`first = first & ~second`). Store the result into `cr`.

## 0405 - i8_inc

Char increment.

Get one char from `SEQ_RegCMD1`. Increment and store it (`value = value++`). Store the result into `cr`.

## 0406 - i8_dec

Char decrement.

Get one char from `SEQ_RegCMD1`. Decrement and store it (`value = value--`). Store the result into `cr`.

## 0407 - i8_add

Char add.

Get two chars from `SEQ_RegCMD2`. Add them and store the result in the first (`first = first + second`). Store the new value into `cr`.

## 0408 - i8_sub

Char subtract.

Get two chars from `SEQ_RegCMD2`. Subtract them and store the result in the first (`first = first - second`). Store the new value into `cr`.

## 0409 - i8_mul

Char multiply.

Get two chars from `SEQ_RegCMD2`. Multiply them and store the result in the first (`first = first * second`). Store the new value into `cr`.

## 040A - i8_div

Char divide.

Get two chars from `SEQ_RegCMD2`. Divide them and store the result in the first (`first = first / second`). Store the new value into `cr`.

## 040B - i8_shl

Char shift left.

Get two chars from `SEQ_RegCMD2`. Shift the first value left by the second value and store the result in the first (`first = first << second`). Store the new value into `cr`.

## 040C - i8_shr

Char shift right.

Get two chars from `SEQ_RegCMD2`. Shift the first value right by the second value and store the result in the first (`first = first >> second`). Store the new value into `cr`.

## 040D - i8_and

Char logical and.

Get two chars from `SEQ_RegCMD2`. Logical `and` the first value with the second value and store the result in the first (`first = first & second`). Store the new value into `cr`.

## 040E - i8_or

Char logical or.

Get two chars from `SEQ_RegCMD2`. Logical `or` the first value with the second value and store the result in the first (`first = first | second`). Store the new value into `cr`.

## 040F - i8_xor

Char logical xor.

Get two chars from `SEQ_RegCMD2`. Logical `xor` the first value with the second value and store the result in the first (`first = first ^ second`). Store the new value into `cr`.

## 0410 - i8_not

Char logical not.

Get two chars from `SEQ_RegCMD2`. Logical `not` the second value and store the result in the first (`first = ~second`). Store the new value into `cr`.

## 0411 - i8_sub.

Char subtraction (without store).

Get two chars from `SEQ_RegCMD2`. Subtract them and store the result in `cr` (`cr = first - second`).

## 0412 - i8_chs

Char change sign.

Get two chars from `SEQ_RegCMD2`. Change the sign of the second value and store the result in the first (`first = -(second)`). Store the new value into `cr`.

## 0413

## 0414

## 0415 - i8_rand

Appears to get a random byte. Requires a value on the stack (`stackVal`). First calls `SEQ_RegCMD2` to get two operands (`operand1` and `operand2`).

Returns a random byte starting from `stackVal` to `operand2` and stores it in `operand1`. Pretty sure it's inclusive on both ends.

## 0416
