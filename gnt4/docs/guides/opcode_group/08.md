# Opcode Group 08 - SEQ_CmdF

Float operations (4 bytes).

- [0800 - f32_debug](#0800---f32_debug)
- [0801 - f32_mov](#0801---f32_mov)
- [0802 - f32_move](#0802---f32_move)
- [0803 - f32_add](#0803---f32_add)
- [0804 - f32_sub](#0804---f32_sub)
- [0805 - f32_mul](#0805---f32_mul)
- [0806 - f32_div](#0806---f32_div)
- [0807 - f32_com](#0807---f32_cmp)
- [0808 - f32_chs](#0808---f32_chs)
- [0809 - f32_sqrt](#0809---f32_sqrt)
- [080A - f32_rsqrt](#080A---f32_rsqrt])
- [080B](#080B)
- [080C](#080C)
- [080D](#080D)
- [080E](#080E)
- [080F](#080F)
- [0810](#0810)
- [0811](#0811)
- [0812 - f32_abs](#0812---f32_abs)

## 0800 - f32_debug

Debug `sprintf` the given parameter using the print format `"%4.2f "`.

## 0801 - f32_mov

Move short.

- Two operands from `SEQ_RegCMD2`.
- Stores result in the first operand.
- Stores result in the conditional register `cr`.

```c
op1 = op2
cr = op1
```

## 0802 - f32_move

Move float (ephemeral). Ephemeral in this case means it does not store to `cr`.

- Two operands from `SEQ_RegCMD2`.
- Stores result in the first operand.

```c
op1 = op2
```

## 0803 - f32_add

Float addition.

- Two operands from `SEQ_RegCMD2`.
- Stores result in the first operand.
- Stores result in the conditional register `cr`.

```c
op1 = op1 + op2
cr = op1
```

## 0804 - f32_sub

Float subtraction.

- Two operands from `SEQ_RegCMD2`.
- Stores result in the first operand.
- Stores result in the conditional register `cr`.

```c
op1 = op1 - op2
cr = op1
```

## 0805 - f32_mul

Float multiply.

- Two operands from `SEQ_RegCMD2`.
- Stores result in the first operand.
- Stores result in the conditional register `cr`.

```c
op1 = op1 * op2
cr = op1
```

## 0806 - f32_div

Float divide.

- Two operands from `SEQ_RegCMD2`.
- Stores result in the first operand.
- Stores result in the conditional register `cr`.

```c
op1 = op1 / op2
cr = op1
```

## 0807 - f32_cmp

Float compare. Set `cr` to 1 is `op1` is larger than `op2`. Set `cr` to -1 is `op2` is larger than `op1`. Set `cr` to 0 if `op1` and `op2` are roughly equal.

- Two operands from `SEQ_RegCMD2`.
- Stores result in the conditional register `cr`.

```c
epsilon = 0.0001 // to handle rounding error
if (op1 - op2 <= epsilon) {
    if (op2 - op1 <= epsilon) {
        cr = 0 // op1 and op2 are roughly equal
    }
    else {
        cr = -1 // op2 is larger
    }
}
else {
    cr = 1 // op1 is larger
}
```

## 0808 - f32_chs

Float change sign.

- Two operands from `SEQ_RegCMD2`.
- Stores result in the first operand.

```c
op1 = -(op2)
cr = op1
```

## 0809 - f32_sqrt

Float square root.

Performs a Reciprocal Square Root Estimate. The `frsqrte` PowerPC instruction generates an estimate of the reciprocal square root, accurate to 1 part in 32. Greater accuracy is desired, so this result serves as the initial seed for a [Newton-Raphson approximation algorithm](https://en.wikipedia.org/wiki/Newton%27s_method).

- Two operands from `SEQ_RegCMD2`.
- Stores result in the first operand.

```c
temp = 0
temp2 = op2
if (0 < temp2) {
    asm (
        "frsqrte %[temp], %[temp2]\n\t" // Floating Reciprocal Square Root Estimate, i.e. 1.0 / sqrt(temp2)
    )
    temp = 0.5 * temp * -(temp2 * temp * temp - 3)
    temp = 0.5 * temp * -(temp2 * temp * temp - 3)
    temp2 = (temp2 * 0.5 * temp * -(temp2 * temp * temp - 3))
}
op1 = temp2
```

## 080A - f32_rsqrt

Float reciprocal (inverse) square root.

Performs a Reciprocal Square Root Estimate. The `frsqrte` PowerPC instruction generates an estimate of the reciprocal square root, accurate to 1 part in 32. Greater accuracy is desired, so this result serves as the initial seed for a [Newton-Raphson approximation algorithm](https://en.wikipedia.org/wiki/Newton%27s_method).

- Two operands from `SEQ_RegCMD2`.
- Stores result in the first operand.

```c
temp = 0
temp2 = 1 / op2
if (0 < temp2) {
    asm (
        "frsqrte %[temp], %[temp2]\n\t" // Floating Reciprocal Square Root Estimate, i.e. 1.0 / sqrt(temp2)
    )
    temp = 0.5 * temp * -(temp2 * temp * temp - 3)
    temp = 0.5 * temp * -(temp2 * temp * temp - 3)
    temp2 = (temp2 * 0.5 * temp * -(temp2 * temp * temp - 3))
}
op1 = temp2
```

## 080B

## 080C

## 080D

## 080E

## 080F

## 0810

## 0811 - f32_mod

Divide two floats and calculate the fractional component (part after the decimal) of the result. In C is equivalent to `modf(op1 / op2, unused)`.

e.g. `f32_mod 6.5, 2.5 = 0.6` and `f32_mod 6.0, 3.0 = 0.0`

```c
op1 = op1 / op2
temp = Runtime.PPCEABI.H::__cvt_fp2unsigned((double) op1) // convert floating-point to 32-bit unsigned integer
temp2 = (double) temp
op1 = op1 - (float)temp2
```

## 0812 - f32_abs

Float absolute value.

- One operand from `SEQ_RegCMD1`.
- Stores result in the first operand.

```c
temp = *op1
asm (
    "fabs %[temp], %[temp]\n\t" // Floating Absolute Value
    "frsp %[temp], %[temp]\n\t" // Floating Round to Single Precision
)
*op1 = temp
```
